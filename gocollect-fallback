#!/bin/sh
# Quick hack to collect data on machines where gocollect fails to work
# because it's not x86_64 or has ancient libc.

conf=/etc/gocollect.conf
path=/usr/share/gocollect/collectors
version=  # gets set before it's put into a tgz package

post() {
    url="$1"
    bindata=$(cat)
    curl --insecure -XPOST --data-binary "$bindata
" "$url"  # enter here to enforce trailing LF
}

log() {
    logger -s -p daemon.warn "gocollect: $@"
}

run() {
    reg_url=$(sed -e '/^register_url/!d;s/.*= *//' "$conf")
    push_url=$(sed -e '/^push_url/!d;s/.*= *//' "$conf")
    
    core_id=$("$path/core.id")
    regid=$(echo "$core_id" | sed -e '/"regid"/!d;s/.*"regid": *"//;s/".*//')
    
    if test -z "$regid"; then
        data=$(echo "$core_id" | post "$reg_url")
        regid=$(echo "$data" | sed -e '/"regid"/!d;s/.*"regid": *"//;s/".*//')
        if test -z "$regid"; then
            log "reg failure"
            exit 1
        fi
        
        mkdir -p /var/lib/gocollect
        chmod 700 /var/lib/gocollect
        echo "$regid" > /var/lib/gocollect/core.id.regid
    
        # Re-get core info. Check values.
        core_id=$("$path/core.id")
        regid=$(echo "$core_id" | sed -e '/"regid"/!d;s/.*"regid": *"//;s/".*//')
        if test -z "$regid"; then
            log "core.id reg load failure"
            exit 1
        fi
    fi

    # Patch core_id with our version.
    if test -n "$version"; then
        self_version="$version.fallback"
    else
        self_version=$(md5sum < "$0" 2>/dev/null | tr -d '\t -')
        self_version="fallback-md5-$self_version"
    fi
    core_id=$(echo "$core_id" | sed -e '/^[[:blank:]]*$/d' |
              sed -e '1s/{/{"gocollect":"'$self_version'",/')
    
    # Jobs
    temp=$(mktemp)
    find "$path" -maxdepth 1 -type f -perm -700 | while read job; do
        case "$job" in
        */core.id)
            # No need to fetch it again. And besides, we patched it
            # above to contain the version as well.
            output="$core_id"
            ret=0
            ;;
        *)
            log "$job: executing"
            output=$("$job" 2>"$temp")
            ret=$?
            test $ret -ne 0 && log "$job: return code was $ret"
            cat "$temp" | while read line; do
                log "$job: (STDERR) $line"
            done
            ;;
        esac

        if test -n "$output" && test $ret -eq 0; then
            collector=$(basename "$job")
            url=$(echo "$push_url" | sed -e "s/{regid}/$regid/g;s/{_collector}/$collector/g")
            log "$job: push to $url"
            echo "$output" | post "$url"
        fi
    done
    rm -f "$temp"
}

while :; do
    run
    sleep 28800  # 8 hours
done
